import { OutputTargetCustom, TypesImportData, Config, ValidatedConfig } from '@stencil/core/internal';
import { CompilerCtx, BuildCtx, JsonDocs } from '@stencil/core/internal';
import { loadConfig } from '@stencil/core/compiler';
import { parseFlags } from '@stencil/core/cli';
import { writeFileSync } from 'fs';
import { isAbsolute, join } from 'path';
import { normalizePath, relative, sortImportNames, updateReferenceTypeImports } from './components-config.stencil';

export function componentConfig(): OutputTargetCustom {
  return {
    type: 'custom',
    name: 'component-option',
    async generator(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, docs: JsonDocs) {
      const lines: string[] = [];
      lines.push(
        '/* eslint-disable */',
        '/* tslint:disable */',
        '/**',
        ' * This is an autogenerated file created by the Cheese-grinder stencil Plugin.',
        ' * It contains typing information for all configurable components that exist in this project.',
        ' */',
      );
  
      const flags = parseFlags(process.argv);
      const validated = await loadConfig({
        config: {
          flags,
        },
        configPath: config.configPath,
        logger: config.logger,
        sys: config.sys,
      });
      const types = typeImportData(validated.config, buildCtx);
      const typeLines = Object.keys(types).map(filePath => {
        const typeData = types[filePath];

        let importFilePath = filePath;
        if (isAbsolute(filePath)) {
          importFilePath = normalizePath('./' + relative(config.srcDir!, filePath)).replace(/\.(tsx|ts)$/, '');
        }
        
        return `import { ${typeData
          .sort(sortImportNames)
          .map((td) => {
            if (td.localName === td.importName) {
              return `${td.importName}`;
            } else {
              return `${td.localName} as ${td.importName}`;
            }
          })
          .join(`, `)} } from "${importFilePath}";`;
      });
      lines.push(...typeLines);
      lines.push('');

      lines.push('export interface ComponentOptions {');
      buildCtx.components
        .filter(component => (
          component.properties
            .some(prop => (
              prop.docs.tags.some(tag => tag.name === 'config')
            ))
        ))
        .forEach(component => {
          lines.push(`  "${component.tagName}"?: {`);

          component.properties
            .filter(prop => prop.docs.tags.some(tag => tag.name === 'config'))
            .forEach(prop => {
              if (prop.docs.text) {

                lines.push('    /**');
                lines.push('     *');
                prop.docs.text.split('\r\n').forEach(line => (
                  lines.push(`     * ${line}`)
                ));
                lines.push('     */');
              }
              const type = prop.complexType.original in prop.complexType.references
                ? prop.complexType.original
                : prop.complexType.resolved;

              lines.push(`    ${prop.name}?: ${type};`)
            });
          lines.push('  }');
        });

      lines.push('}');

      config.srcDir
      writeFileSync(join(
        config.srcDir!, 'component-config.d.ts'
      ), lines.join('\n'));
    },
  };
}


function typeImportData(config: ValidatedConfig, { components }: BuildCtx) {
  let importTypeData: TypesImportData = {};
  const allTypes = new Map<string, number>();

  components
    .filter(c => !c.isCollectionDependency)
    .forEach((comp) => {
      importTypeData = updateReferenceTypeImports(importTypeData, allTypes, comp, comp.sourceFilePath, config)
    })
    const expressions = Object.keys(typeImportData).map((filePath) => {
      const typeData = typeImportData[filePath];

      let importFilePath = filePath;
      if (isAbsolute(filePath)) {
        importFilePath = normalizePath('./' + relative(config.srcDir!, filePath)).replace(/\.(tsx|ts)$/, '');
      }

      return `{ ${typeData
        .sort(sortImportNames)
        .map((td) => {
          if (td.localName === td.importName) {
            return `${td.importName}`;
          } else {
            return `${td.localName} as ${td.importName}`;
          }
        })
        .join(`, `)} } from "${importFilePath}";`;
    });

  return importTypeData;
}