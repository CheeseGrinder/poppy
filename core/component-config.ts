import { parseFlags } from '@stencil/core/cli';
import { loadConfig } from '@stencil/core/compiler';
import { BuildCtx, CompilerCtx, ComponentCompilerProperty, Config, JsonDocs, OutputTargetCustom, TypesImportData, ValidatedConfig } from '@stencil/core/internal';
import { writeFileSync } from 'fs';
import { isAbsolute, join } from 'path';
import { normalizePath, relative, sortImportNames, updateReferenceTypeImports } from './components-config.stencil';

export function componentConfig(): OutputTargetCustom {
  return {
    type: 'custom',
    name: 'component-option',
    async generator(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, docs: JsonDocs) {
      const lines: string[] = [];
      lines.push(
        '/* eslint-disable */',
        '/* tslint:disable */',
        '/**',
        ' * This is an autogenerated file created by the Cheese-grinder stencil Plugin.',
        ' * It contains typing information for all configurable components that exist in this project.',
        ' */',
      );

      const validated = await loadConfig({
        config: {
          flags: parseFlags(process.argv),
        },
        configPath: config.configPath,
        logger: config.logger,
        sys: config.sys,
      });
      const types = typeImportData(validated.config, buildCtx);
      types.forEach(type => lines.push(`import ${type}`));
      lines.push('');

      lines.push('export interface ComponentOptions {');
      buildCtx.components.forEach(component => {
        const props = component.properties.filter(hasConfigProp);
        if (props.length === 0) {
          return;
        }

        lines.push(`  "${component.tagName}"?: {`);

        props.forEach(prop => {
          if (prop.docs.text) {
            lines.push('    /**');
            prop.docs.text.split(/[\r\n]+/).forEach(line => lines.push(`     * ${line}`));
            lines.push('     */');
          }
          lines.push(`    ${prop.name}?: ${prop.complexType.original};`);
        });
        lines.push('  }');
      });
      lines.push('}');

      writeFileSync(join(config.srcDir!, 'component-config.d.ts'), lines.join('\n'));
    },
  };
}

function hasConfigProp(prop: ComponentCompilerProperty): boolean {
  return prop.docs.tags.some(tag => tag.name === 'config')
}

function typeImportData(config: ValidatedConfig, { components }: BuildCtx) {
  const allTypes = new Map<string, number>();

  const importTypeData = components
    .filter(c => !c.isCollectionDependency)
    .reduce((importType, comp) => (
      updateReferenceTypeImports(importType, allTypes, comp, comp.sourceFilePath, config)
    ), {} as TypesImportData);

   return Object.keys(importTypeData).map(filePath => {
    const typeData = importTypeData[filePath];

    let importFilePath = filePath;
    if (isAbsolute(filePath)) {
      importFilePath = normalizePath('./' + relative(config.srcDir!, filePath)).replace(/\.(tsx|ts)$/, '');
    }

    return `{ ${typeData
      .sort(sortImportNames)
      .map(td => {
        if (td.localName === td.importName) {
          return `${td.importName}`;
        } else {
          return `${td.localName} as ${td.importName}`;
        }
      })
      .join(`, `)} } from "${importFilePath}";`;
  });
}
